use_sp = True

pdist = lambda X: sp.spatial.distance.cdist(X,X) if use_sp else pairwise_distances(X)
def loss_WPCMS(X, Z, W, beta):
  D = pdist(X)
  obj = W * (Z + beta - D**2)**2
  return(np.mean(obj))

def deriv_WPCMS(X, Z, W, beta):
  D = pdist(X)
  G = W * (Z + beta - D**2)
  G_plus = np.diag(G.sum(axis = 1))
  return(G - G_plus)

def line_search_WPCMS(X, Z, W, H, beta, obj0):
  S = X @ X.T
  G = deriv_WPCMS(X, Z, W, beta)
  
  rate = 2
  obj = np.inf
  rank = 0
  
  while(obj0 < obj or rank < 3):
    rate = rate / 2
    pcms = PCMS(S - rate * G, H)
    obj = loss_WPCMS(H @ pcms[0], Z, W, beta)
    rank = pcms[3]
    if(rate < 1e-20):
      return [None, 0]
  return [pcms[0], rate]

def update_param_WPCMS(X, Z, W):
  D = pdist(X)
  beta = -np.sum(W * (Z - D**2))/np.sum(W)
  return(beta)

def WPCMS(Z, H, W = np.ones(Z.shape), Theta = None, beta = None,
                update_beta = True, eps = 1e-6, maxiter = 100, verbose = False):
  #Initialize
  if Theta is None:
    Theta = np.random.normal(size = (H.shape[1], 3))
  if beta is None:
    beta = -np.min(Z)
  print(H.shape, Theta.shape)
  X = H @ Theta
  X = scale(X, scale = False, center = True)
  obj = loss_WPCMS(X, Z, W, beta)
  
  delta = np.inf
  iter = 0
  
  #Iterate
  while(delta > eps and iter < maxiter):
    print('objective', obj)
    iter = iter + 1
    obj0 = obj
    
    #Line search
    find = line_search_WPCMS(X, Z, W, H, beta, obj0)
    
    #Update solution
    if(find[1] > 0):
      Theta = find[0]
    X = H @ Theta
    X = scale(X, scale = False, center = True)
    
    #Update beta
    if(update_beta):
      beta = update_param_WPCMS(X, Z, W)
    
    #Update loss
    obj = loss_WPCMS(X, Z, W, beta)
    delta = abs((obj0 - obj)/obj0)
  
  return [Theta, X, beta, obj, iter]